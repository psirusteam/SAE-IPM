```{r setup, include=FALSE, message=FALSE, error=FALSE, warning=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  cache = TRUE
)
library(tidyverse)
library(rstantools)
library(rstan)
library(posterior)
library(patchwork)
library(lme4)
library(rstanarm)
library(magrittr)
library(furrr)
library(kableExtra)

tba <- function(dat, cap = NA){
  kable(dat,
      format = "html", digits =  4,
      caption = cap) %>% 
     kable_styling(bootstrap_options = "striped", full_width = F)%>%
         kable_classic(full_width = F, html_font = "Arial Narrow")
}
```

# Aplicación: Índice de Pobreza Multidimensional en Colombia. 

Nos centramos en la incidencia de la pobreza multidimensional descrito previamente. En este caso, requerimos $K = 8$ indicadores que se miden como privaciones: $y_{di}^{k} = 1$ si la persona tiene la privación y $y_{di}^{k} = 0$ si la persona no ha tenido la privación.

El índice requiere información para cada individuo $i = 1, \ldots, N_d$ en los dominios $d = 1, \ldots, D$, donde $N_d$ denota el tamaño de la población del dominio $d$.

La función indicadora $I(\cdot)$ es igual a 1 cuando se cumple la condición $q_{di} > z$. Para este estudio, utilizamos el valor de 0.4 para $z$, es decir, $I(\cdot)$ es igual a 1 cuando $q_{di} > 0.4$. $q_{di}$ es una cantidad ponderada que considera los $K = 8$ indicadores que conforman el índice. El valor de $q_{di}$ el dominio $d$ se calcula como:
  
$$
  q_{di} = 0.1\sum_{k=1}^{6}y_{di}^{k} +  0.2(y_{di}^{7} + y_{di}^{8})
$$
  
  Donde: 
  a. $y_{di}^{1}$ = Privación en material de construcción de la vivienda

  b. $y_{di}^{2}$ = Hacinamiento en el hogar. 

  c. $y_{di}^{3}$ = Privación de acceso al agua potable. 

  d. $y_{di}^{4}$ = Privación en saneamiento.

  e. $y_{di}^{5}$ = Acceso al servicio energía eléctrica. 

  f. $y_{di}^{6}$ = Acceso al servicio de internet.

  g. $y_{di}^{7}$ = Privación de la educación. 

  h. $y_{di}^{8}$ = Privación del empleo y la protección social.  

Note que, la primera parte de la suma considera los indicadores de las dimensiones de vivienda, agua y saneamiento, energía y conectividad. La segunda parte, los indicadores de las dimensiones de educación y empleo y protección social. 

Los datos de la encuesta y el censo han sido preparados previamente, la información sobre la cual realizaremos la predicción corresponde a Colombia en el 2019 

```{r, eval=TRUE}
encuesta_ipm <-
  readRDS("Modelo_bayes_HxA/COL/Data/encuesta_COL.rds")
statelevel_predictors_df <-
  readRDS("Modelo_bayes_HxA/COL/Data/statelevel_predictors_df_dam2.rds") %>% 
  rename(depto = dam, mpio = dam2)

byAgrega <- c("depto",
              "mpio",
              "area",
              "sexo",
              "etnia",
              "anoest",
              "edad",
              "condact3")
```

Agregando la información para los municipios de Colombia para los indicadores que conformarán el IPM

```{r, eval=TRUE}
names_ipm <- grep(pattern = "ipm", names(encuesta_ipm),value = TRUE)

encuesta_df <- map(setNames(names_ipm,names_ipm),
    function(y){
  encuesta_ipm$temp <- encuesta_ipm[[y]]
  encuesta_ipm %>% 
  group_by_at(all_of(byAgrega)) %>%
  summarise(n = n(),
            yno = sum(temp),
            ysi = n - yno, .groups = "drop") %>% 
    inner_join(statelevel_predictors_df,
                              by = c("depto","mpio"))
})

  
```

La base resultante quedan de la siguiente forma:

```{r, echo=FALSE}
tba(encuesta_df[[names_ipm[1]]] %>% arrange(desc(n)) %>% head(), 
    cap = "Privaci\'on en material de construcci\'on de la vivienda")
```

```{r, echo=FALSE}
tba(encuesta_df[[names_ipm[2]]] %>% arrange(desc(n)) %>% head(), 
    cap = "Hacinamiento")

```

## Definiendo de los modelos en Stan.

Para cada dimensión que compone el IPM se ajusta un modelo mixtos logit Bernoulli estimando mediante técnicas bayesiana. En este código se incluye el uso de la función `future_map` que permite procesar en paralelo cada modelo O puede compilar cada por separado, en nuestro caso se proceso cada modelo por separado.    

```{r, eval = FALSE}
library(furrr)
plan(multisession, workers = 4)

fit <- future_map(encuesta_df, function(xdat){
stan_glmer(
  cbind(yno, ysi) ~ (1 | mpio) +
    (1 | depto) +
    edad +
    area +
    anoest +
    etnia +
    sexo + 
    tasa_desocupacion ,
  family = binomial(link = "logit"),
  data = xdat,
  cores = 7,
  chains = 4,
  iter = 300
)}, 
.progress = TRUE)

saveRDS(object = fit, "Data/fits_IPM.rds")

```

Terminado la compilación de los modelos después de realizar validaciones sobre esto, pasamos hacer las predicciones en el censo. 

## Proceso para la predicción $\pi_{di}^{kl}$

Los modelos fueron compilados de manera separada, por tanto, disponemos de un objeto `.rds` por cada dimensión del IPM 

```{r, eval=FALSE}

fit_agua <-
  readRDS(file = "Modelo_bayes_HxA/COL/Data/fit_bayes_agua.rds")
fit_educacion <-
  readRDS(file = "Modelo_bayes_HxA/COL/Data/fit_bayes_educacion.rds")
fit_empleo <-
  readRDS(file = "Modelo_bayes_HxA/COL/Data/fit_bayes_empleo.rds")
fit_energia <-
  readRDS(file = "Modelo_bayes_HxA/COL/Data/fit_bayes_Energia.rds")
fit_hacinamiento <-
  readRDS(file = "Modelo_bayes_HxA/COL/Data/fit_bayes_Hacinamiento.rds")
fit_internet <-
  readRDS(file = "Modelo_bayes_HxA/COL/Data/fit_bayes_internet.rds")
fit_material <-
  readRDS(file = "Modelo_bayes_HxA/COL/Data/fit_bayes_material.rds")
fit_saneamiento <-
  readRDS(file = "Modelo_bayes_HxA/COL/Data/fit_bayes_saneamiento.rds")

```


Ahora, debemos leer la información del censo  y crear los **post-estrato **
```{r}
censo_ipm <- readRDS("Modelo_bayes_HxA/COL/Data/censo_COL.rds") %>%
  rename(dam = depto, dam2 = mpio) %>%
  group_by(dam,   dam2,  area,  sexo,  edad,  etnia, anoest) %>%
  summarise(n = sum(n), .groups = "drop")

statelevel_predictors_df <-
  readRDS("Modelo_bayes_HxA/COL/Data/statelevel_predictors_df_dam2.rds") 

```

Para realizar la predicción en el censo debemos incluir la información auxiliar 

```{r}
poststrat_df <- left_join(censo_ipm, statelevel_predictors_df,
                          by = c("dam", "dam2")) %>% 
  rename(depto = dam,  mpio = dam2) 

```


Para cada uno de los modelos anteriores debe tener las $L$ predicciones de $\pi_{di}^{kl}$,

-   Privación de acceso al agua potable. 
```{r, eval=FALSE}
temp <- poststrat_df 
epred_mat_agua <- posterior_epred(
  fit_agua,
  newdata = temp,
  type = "response",
  allow.new.levels = TRUE
)
```

-   Privación de la educación.

```{r, eval =FALSE}
epred_mat_educacion <-
  posterior_epred(
    fit_educacion,
    newdata = temp,
    type = "response",
    allow.new.levels = TRUE
  )
```

-   Privación del empleo y la protección social.

```{r, echo=TRUE, eval=FALSE}
epred_mat_empleo <-
  posterior_epred(
    fit_empleo,
    newdata = temp,
    type = "response",
    allow.new.levels = TRUE
  )
```

-   Acceso al servicio energía eléctrica.

```{r, echo=TRUE, eval=FALSE}
epred_mat_energia <-
  posterior_epred(
    fit_energia,
    newdata = temp,
    type = "response",
    allow.new.levels = TRUE
  )
```

-    Hacinamiento en el hogar.

```{r, echo=TRUE, eval=FALSE}
epred_mat_hacinamiento <-
  posterior_epred(
    fit_hacinamiento,
    newdata = temp,
    type = "response",
    allow.new.levels = TRUE
  )
```

-   Acceso al servicio de Internet.

```{r, echo=TRUE, eval=FALSE}
epred_mat_internet <-
  posterior_epred(
    fit_internet,
    newdata = temp,
    type = "response",
    allow.new.levels = TRUE
  )
```

-   Privación en material de construcción de la vivienda

```{r, echo=TRUE, eval =FALSE}
epred_mat_material <-
  posterior_epred(
    fit_material,
    newdata = temp,
    type = "response",
    allow.new.levels = TRUE
  )
```

-   Privación en saneamiento.

```{r, echo=TRUE, eval = FALSE}
epred_mat_saneamiento <-
  posterior_epred(
    fit_saneamiento,
    newdata = temp,
    type = "response",
    allow.new.levels = TRUE
  )

```

```{r, echo=FALSE, eval=FALSE}
saveRDS(epred_mat_agua, "Modelo_bayes_HxA/COL/Data/epred_mat_agua.rds")
saveRDS(epred_mat_educacion, "Modelo_bayes_HxA/COL/Data//epred_mat_educacion.rds")
saveRDS(epred_mat_empleo, "Modelo_bayes_HxA/COL/Data//epred_mat_empleo.rds")
saveRDS(epred_mat_energia, "Modelo_bayes_HxA/COL/Data//epred_mat_energia.rds")
saveRDS(epred_mat_hacinamiento, "Modelo_bayes_HxA/COL/Data//epred_mat_hacinamiento.rds")
saveRDS(epred_mat_internet, "Modelo_bayes_HxA/COL/Data/epred_mat_internet.rds")
saveRDS(epred_mat_material, "Modelo_bayes_HxA/COL/Data/epred_mat_material.rds")
saveRDS(epred_mat_saneamiento, "Modelo_bayes_HxA/COL/Data/epred_mat_saneamiento.rds")

```

## Definiendo los hard estimates

Los resultados anteriores se deben procesarse para obtener los hard estimates, es decir, términos de carencia (1) y  no carencia (0) para la $k-esima$ dimensión . 

-    Privación de acceso al agua potable. 


```{r,eval=FALSE}
epred_mat_agua_dummy <-
  rbinom(n = nrow(epred_mat_agua) * ncol(epred_mat_agua) , 1,
         epred_mat_agua)

epred_mat_agua_dummy <- matrix(
  epred_mat_agua_dummy,
  nrow = nrow(epred_mat_agua),
  ncol = ncol(epred_mat_agua)
)
```

-   Privación de la educación.


```{r,eval=FALSE}
epred_mat_educacion_dummy <-
  rbinom(n = nrow(epred_mat_educacion) * ncol(epred_mat_educacion) ,
         1,
         epred_mat_educacion)

epred_mat_educacion_dummy <- matrix(
  epred_mat_educacion_dummy,
  nrow = nrow(epred_mat_educacion),
  ncol = ncol(epred_mat_educacion)
)
```

-    Acceso al servicio energía eléctrica 


```{r,eval=FALSE}
epred_mat_energia_dummy <-
  rbinom(n = nrow(epred_mat_energia) * ncol(epred_mat_energia) ,
         1,
         epred_mat_energia)

epred_mat_energia_dummy <- matrix(
  epred_mat_energia_dummy,
  nrow = nrow(epred_mat_energia),
  ncol = ncol(epred_mat_energia)
)
```

-   Hacinamiento en el hogar.


```{r,echo = TRUE,eval=FALSE}
epred_mat_hacinamiento_dummy <-
  rbinom(
    n = nrow(epred_mat_hacinamiento) * ncol(epred_mat_hacinamiento) ,
    1,
    epred_mat_hacinamiento
  )

epred_mat_hacinamiento_dummy <-
  matrix(
    epred_mat_hacinamiento_dummy,
    nrow = nrow(epred_mat_hacinamiento),
    ncol = ncol(epred_mat_hacinamiento)
  )
```

-   Acceso al servicio de Internet.


```{r,echo = TRUE,eval=FALSE}
epred_mat_internet_dummy <-
  rbinom(n = nrow(epred_mat_internet) * ncol(epred_mat_internet) ,
         1,
         epred_mat_internet)

epred_mat_internet_dummy <- matrix(
  epred_mat_internet_dummy,
  nrow = nrow(epred_mat_internet),
  ncol = ncol(epred_mat_internet)
)
```

-   Privación en material de construcción de la vivienda 


```{r, echo = TRUE,eval=FALSE}
epred_mat_material_dummy <-
  rbinom(n = nrow(epred_mat_material) * ncol(epred_mat_material) ,
         1,
         epred_mat_material)

epred_mat_material_dummy <- matrix(
  epred_mat_material_dummy,
  nrow = nrow(epred_mat_material),
  ncol = ncol(epred_mat_material)
)
```

-   Privación en saneamiento. 


```{r, echo = TRUE, eval=FALSE}
epred_mat_saneamiento_dummy <-
  rbinom(n = nrow(epred_mat_saneamiento) * ncol(epred_mat_saneamiento) ,
         1,
         epred_mat_saneamiento)

epred_mat_saneamiento_dummy <- matrix(
  epred_mat_saneamiento_dummy,
  nrow = nrow(epred_mat_saneamiento),
  ncol = ncol(epred_mat_saneamiento)
)
```

-   Privación del empleo y la protección social. 


```{r, echo = TRUE, eval=FALSE}
epred_mat_empleo_dummy <-
  rbinom(n = nrow(epred_mat_empleo) * ncol(epred_mat_empleo) ,
         1,
         epred_mat_empleo)

epred_mat_empleo_dummy <- matrix(
  epred_mat_empleo_dummy,
  nrow = nrow(epred_mat_empleo),
  ncol = ncol(epred_mat_empleo)
)

```


```{r, echo=FALSE, eval=FALSE}
saveRDS(epred_mat_agua_dummy, "Modelo_bayes_HxA/COL/Data/epred_mat_agua_dummy.rds")
saveRDS(epred_mat_educacion_dummy, "Modelo_bayes_HxA/COL/Data/epred_mat_educacion_dummy.rds")
saveRDS(epred_mat_empleo_dummy, "Modelo_bayes_HxA/COL/Data/epred_mat_empleo_dummy.rds")
saveRDS(epred_mat_energia_dummy, "Modelo_bayes_HxA/COL/Data/epred_mat_energia_dummy.rds")
saveRDS(epred_mat_hacinamiento_dummy, "Modelo_bayes_HxA/COL/Data/epred_mat_hacinamiento_dummy.rds")
saveRDS(epred_mat_internet_dummy, "Modelo_bayes_HxA/COL/Data/epred_mat_internet_dummy.rds")
saveRDS(epred_mat_material_dummy, "Modelo_bayes_HxA/COL/Data/epred_mat_material_dummy.rds")
saveRDS(epred_mat_saneamiento_dummy, "Modelo_bayes_HxA/COL/Data/epred_mat_saneamiento_dummy.rds")

```

## Calculando $q_{di}^{l}$ y $I\left( q_{di}^{l} > z \right)$ 

Dado que los hard estimates fueron organizados en matrices, el calculo de $q^{l}_{id}$ es una simple operación matricial la cual se muestra a continuación 
```{r, eval=FALSE}
chain_q  <- 0.1 * (
  epred_mat_material_dummy +
    epred_mat_hacinamiento_dummy +
    epred_mat_agua_dummy +
    epred_mat_saneamiento_dummy +
    epred_mat_energia_dummy + epred_mat_internet_dummy
) +
  0.2 * (epred_mat_educacion_dummy +
           epred_mat_empleo_dummy)

```

```{r,echo=FALSE}
chain_q <- readRDS("Modelo_bayes_HxA/COL/Data/chain_q.rds")

```

Ahora, es posible tener el calculo de $I\left( q_{di}^{l} > z \right)$, tomando como umbral $z=0.4$. 

```{r, eval=TRUE}
chain_Indicadora <- chain_q
chain_Indicadora[chain_Indicadora <= 0.4] <- 0
chain_Indicadora[chain_Indicadora != 0] <- 1
```


```{r, eval=TRUE}
datos<-data.frame(chain_q[1:10,1:5], chain_Indicadora[1:10,1:5])
colnames(datos) <- c(paste0("q",1:5), paste0("Ind",1:5))
tba(datos, "Cadenas obtenidas")
```

## Estimación de $H$, $A$ e $IPM$
Para este proceso debemos realizar sumas ponderadas, dado que cada registro de la base de datos representa  un grupo de observaciones con las mismas características.  

```{r}
D <- rowSums(chain_Indicadora*censo_ipm$n)
Q <- rowSums(chain_q*censo_ipm$n)
chain_H =  D/sum(censo_ipm$n)
chain_A = Q/((sum(censo_ipm$n))*8)
chain_IPM <- (D*Q)/((sum(censo_ipm$n)^2)*8)
```

```{r, echo=FALSE}
datos_chain <- data.frame(chain_H = chain_H[1:5], 
                          chain_A = chain_A[1:5], 
                          chain_IPM = chain_IPM[1:5])
rownames(datos_chain) <- paste0("l = ", 1:5)
tba(datos_chain, "l-iteraciones")
```


Por último se realiza las estimaciones puntuales y varianza para $H$, $A$ y $IPM$, esto es:  

```{r}
estimacion <- data.frame(H = mean(chain_H),
           H_sd = sd(chain_H),
           A = mean(chain_A),
           A_sd = sd(chain_A),
           IPM = mean(chain_IPM),
           IPM_sd = sd(chain_IPM))
```


```{r, echo=FALSE}
tba(estimacion, "Estimaciones Nacionales")
```
## Estimaciones desagregadas del IPM

Para realizar las estimaciones desagregadas se desarrollo una función que facilita el calculo, la estructura general el proceso es repetir el proceso anterior por subgrupos, por ejemplo, departamento (*dam*)

```{r}
source("Modelo_bayes_HxA/0funciones/Estimar_ipm.R")
ipm_dam <- estime_IPM(poststrat = censo_ipm,
           chain_q,
           byMap = "dam", 
           n_dim = 8) %>% data.frame()
```


```{r, echo=FALSE}
tba(ipm_dam, "Estimaciones por departamento")
```

Otra estimación desagregada que es posible obtener es la combinación por departamento y sexo, para ellos se usa la sintaxis. 


```{r}
ipm_dam_sexo <- estime_IPM(poststrat = censo_ipm,
           chain_q,
           byMap = c("dam", "sexo"), 
           n_dim = 8) %>% data.frame()
```


```{r, echo=FALSE}
tba(ipm_dam_sexo, "Estimaciones por departamento y sexo")
```

# Mapa del IPM por municipio de Colombia

Dado que los municipios son otro nivel de desagregción, es posible realizar un mapa municipal para $H$, $A$ e $IPM$. Para realizar el proceso, previamente se guardaron las estimaciones necesarias en un archivo _.rds_ el cual usaremos a continuación:

```{r, echo=TRUE, eval=FALSE}
library(sf)
library(tmap)
estimado_ipm <- readRDS(file = "Modelo_bayes_HxA/COL/Data/estimado_ipm.rds")
ShapeSAE <- read_sf("Modelo_bayes_HxA/COL/Shape/COL_dam2.shp")

brks_H <- c(0, 0.2 ,0.4, .6, 0.8,  1)
brks_ipm <- c(0,0.01 ,0.04, .07, 0.1,  0.15, 0.25)
brks_A <- c(0,0.04 ,0.05, .06,  0.07,.1)

maps3 <- tm_shape(ShapeSAE %>%
                    left_join(estimado_ipm$dam2,  by = "dam2"))

```

Para crear los mapas se usa la siguiente sintaxis 

```{r, echo=TRUE, eval=FALSE}

Mapa_H <-
  maps3 + tm_polygons(
    "H",
    breaks = brks_H,
    title = "H",
    palette = "YlOrRd",
    colorNA = "white"
  ) 

Mapa_A <-
  maps3 + tm_polygons(
    "A",
    breaks = brks_A,
    title = "A",
    palette = "YlOrRd",
    colorNA = "white"
  ) 
Mapa_ipm <-
  maps3 + tm_polygons(
    "ipm",
    breaks = brks_ipm,
    title = "IPM",
    palette = "YlOrRd",
    colorNA = "white"
  ) 


Mapas <- tmap_arrange(Mapa_H, Mapa_A, Mapa_ipm)

tmap_save(
  Mapas,
  "Modelo_bayes_HxA/COL/Output/COL_IPM.jpeg",
  width = 6920,
  height = 4080,
  asp = 0
)

```


```{r echo=FALSE,out.height="400%",fig.align='center'}
knitr::include_graphics("Modelo_bayes_HxA/COL/Output/COL_IPM.jpeg")
```

